{"version":3,"file":"update_manifest.js","sources":["../src/update_manifest.ts"],"sourcesContent":["import { promises } from 'fs';\nimport { join, resolve, basename } from 'path';\n\nimport { pipe } from '@fluss/core';\nimport { ManifestJsonIcon } from 'pwa-asset-generator/dist/models/result';\n\nimport { onceCached } from './once_cached';\nimport { done, oops } from './pretty';\nimport { TransformOptions } from './types';\nimport { buildPublicUrl, makeUrlFromRoot } from './build_public_url';\nimport { DEFAULT_MANIFEST_NAME, DEFAULT_SOURCE_DIRECTORY } from './constants';\n\nexport interface UpdateManifestOptions {\n  icons: ReadonlyArray<ManifestJsonIcon>;\n  pathToManifest: string;\n  pathToOutputManifest: string;\n}\n\n/** Update _icons_ property of manifest file. */\nconst updateManifest = async ({\n  icons,\n  pathToManifest,\n  pathToOutputManifest,\n}: UpdateManifestOptions) =>\n  promises\n    .readFile(pathToManifest, { encoding: 'utf-8' })\n    .then(JSON.parse)\n    .then((manifest) => ({\n      ...manifest,\n      icons: (manifest.icons || []).concat(icons),\n    }))\n    .then(JSON.stringify)\n    .then((data) =>\n      promises.writeFile(pathToOutputManifest, data, { encoding: 'utf-8' })\n    );\n\nexport const handleManifest = onceCached(\n  async (\n    manifestJsonContent: ReadonlyArray<ManifestJsonIcon>,\n    {\n      manifest = {},\n      buildDirectory,\n    }: Pick<TransformOptions, 'manifest'> & { buildDirectory: string }\n  ) => {\n    const pathToManifest = resolve(\n      manifest.pathToManifest ??\n        join(DEFAULT_SOURCE_DIRECTORY, DEFAULT_MANIFEST_NAME)\n    );\n\n    const manifestName = basename(pathToManifest);\n\n    const pathToOutputManifest = resolve(\n      buildDirectory,\n      manifest.publicDirectory ?? '',\n      manifestName\n    );\n\n    await updateManifest({\n      pathToManifest,\n      icons: manifestJsonContent,\n      pathToOutputManifest,\n    }).catch(oops);\n\n    done('Manifest was successfully updated and moved to build directory');\n\n    return (pipe(buildPublicUrl, makeUrlFromRoot) as (\n      ...args: ReadonlyArray<string | undefined>\n    ) => string)(manifest.publicDirectory, manifestName);\n  }\n);\n"],"names":["handleManifest","onceCached","async","manifestJsonContent","manifest","buildDirectory","pathToManifest","resolve","join","DEFAULT_SOURCE_DIRECTORY","DEFAULT_MANIFEST_NAME","manifestName","basename","pathToOutputManifest","publicDirectory","icons","promises","readFile","encoding","then","JSON","parse","concat","stringify","data","writeFile","updateManifest","catch","oops","done","pipe","buildPublicUrl","makeUrlFromRoot"],"mappings":"0TAmBA,MAiBaA,EAAiBC,cAC5BC,MACEC,GAEEC,SAAAA,EAAW,GACXC,eAAAA,cAGF,MAAMC,EAAiBC,oBACrBH,EAASE,8BACPE,OAAKC,2BAA0BC,0BAG7BC,EAAeC,WAASN,GAExBO,EAAuBN,UAC3BF,YACAD,EAASU,+BAAmB,GAC5BH,GAWF,YA9CmBT,QACrBa,MAAAA,EACAT,eAAAA,EACAO,qBAAAA,KAEAG,WACGC,SAASX,EAAgB,CAAEY,SAAU,UACrCC,KAAKC,KAAKC,OACVF,MAAMf,kCACFA,IACHW,OAAQX,EAASW,OAAS,IAAIO,OAAOP,OAEtCI,KAAKC,KAAKG,WACVJ,MAAMK,GACLR,WAASS,UAAUZ,EAAsBW,EAAM,CAAEN,SAAU,YAwBvDQ,CAAe,CACnBpB,eAAAA,EACAS,MAAOZ,EACPU,qBAAAA,IACCc,MAAMC,QAETC,OAAK,kEAEGC,OAAKC,iBAAgBC,kBAArBF,CAEK1B,EAASU,gBAAiBH"}